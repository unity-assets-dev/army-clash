Приложение начинается с единой точки входа AppEntry, в которой собираются все зависимости в отдельные состояния(под капотом простая машина состояний), что позволяет гибко управлять приложением и разделять код на части, подразумевается использование смеси MVVM\MVP и довольно просто потом можно интегрировать DiContainer (уже отработано не на одном десятке приложений). 

Для размещения, используется сетка, на которой можно произвольно размещать юнитов, которые создаются в фабрике юнитов (которую позднее можно заменить на пул). Для упрощения, юниты совмещают данные и представление в MonoBehaviour и обновляются в одном методе Update, но их можно разделить, в данном случае это не играет большой роли.

В качестве модуля ИИ, я выбрал дерево поведения, но в данном случае легко можно было обойтись и машиной состояний. Дерево поведений мне нравится гибкостью, расширяемостью и независимостью от управляемых объектов.

Конфигурирование юнитов происходит с помощью паттерна декоратор, с помощью которого происходит последовательное наслаивание модификаций,  поверх базовых характеристик; данный подход позволяет гибко и не лимитировано расширять модификаторы. В качестве базы для характеристик и модификаций используются ScriptableObject-ы, но сама система декоратора построена на интерфейсах и можно их заменить на простые файлы, с конфигурированием например в  json-файлах или из внешнего источника (сервер, фаербейс). Тем самым, можно легко добавлять новые вариации форм, цветов и размеров, как в прочем, и новые типы модификаций.

Производительность. Протестировано в редакторе (в два фрейма), работает с вполне приемлемой производительностью на моем ноуте. Можно еще оптимизировать выделение памяти, но поскольку такой задачи не ставилось, не стал углубляться, для большего кол-ва юнитов, логичнее использовать ECS-системы.

	0 юнитов - 430-440 кадров.
	40 юнитов - 400+ кадров.
	400 юнитов - 120 + кадров.
	600 юнитов - 60-70 кадров.

На все потрачено, порядка 14 часов.